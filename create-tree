#!/bin/env ruby

require 'json'
require_relative 'lib'
require_relative 'tree'

TRUNCATED_ROOT = 'Ornithodira'

# @param root [Node]
def to_map(root)
  {
    :value => root.value,
    :children => root.children.map { |c| to_map(c) },
  }
end

# @param root [Node]
def to_wolfram(root)
  def to_wolfram_inner(root, depth)
    name = root.value.format_chinese_name
    if name.include?('：')
      name = name.gsub(/^(.*)：(.*)$/, '[\1] \2')
    end
    subtrees = root.children.map { |x| to_wolfram_inner x, depth + 1 }
    subtrees_str = subtrees.map do |x|
      if x.include?('Tree')
        x
      else
        %{"#{x.gsub('：', '\n')}"}
      end
    end.join(', ')

    stylized_name = %{Style["#{name}", FontSize -> Larger]}
    orange_node_style = 'TreeElementStyle -> {LightOrange}'
    if root.children.length == 0
      # highlight leaves
      return %{Tree[#{stylized_name}, {#{subtrees_str}}, #{orange_node_style}]}
    end
    %{Tree[#{stylized_name}, {#{subtrees_str}}]}
  end

  to_wolfram_inner root, 0
end

# @param path [String]
# @return [Array<Array<Taxon>>]
def parse_lineage_txt(path)
  read = File.read path
  chunks = read.split "\n\n"
  chunks.map do |c|
    c.lines(chomp: true).map do |line|
      # format: rank_display display sci_name
      split = line.split ' '
      fail if split.length != 3
      Taxon.new(split[0], split[1], split[2], nil)
    end
  end
end

# @param lineage [Array<Taxon>]
# @return [Array<Taxon>]
def lineage_truncate_root(root_sci_name, lineage)
  root_index = lineage.rindex { |x| x.sci_name == root_sci_name }
  fail 'TRUNCATED_ROOT not found' if root_index == nil
  lineage = lineage[root_index...]
  fail if lineage == nil
  lineage
end

parsed = parse_lineage_txt 'lineage.txt'

tree = Tree.new
parsed.each do |lineage|
  if TRUNCATED_ROOT != nil
    lineage = lineage_truncate_root TRUNCATED_ROOT, lineage
  end
  tree.add_lineage lineage
end

puts to_wolfram tree.root
